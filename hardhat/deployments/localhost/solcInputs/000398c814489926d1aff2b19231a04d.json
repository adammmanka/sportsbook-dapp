{
  "language": "Solidity",
  "sources": {
    "contracts/SportsbookBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nstruct MatchChallenge {\n    address team1;\n    address team2;\n    bool accepted;\n    bool started;\n    bool finished;\n    uint256 amount;\n    address locationProvider;\n}\n\ncontract SportsbookBase {\n    MatchChallenge[] public matchChallenges;\n\n    event ChallengeResult(\n        uint256 indexed MatchChallengeId,\n        uint8 team1Result,\n        uint8 team2Result\n    );\n\n    constructor() payable {}\n\n    function createChallenge(\n        address _team2,\n        address locationProvider\n    ) public payable {\n        matchChallenges.push(\n            MatchChallenge(\n                msg.sender,\n                _team2,\n                false,\n                false,\n                false,\n                msg.value,\n                locationProvider\n            )\n        );\n    }\n\n    function acceptChallenge(uint256 _challengeId) public payable {\n        require(\n            msg.sender == matchChallenges[_challengeId].team2,\n            \"You're not the challenged team!\"\n        );\n        require(\n            msg.value >= matchChallenges[_challengeId].amount,\n            \"Haven't sent enough ETH!\"\n        );\n        matchChallenges[_challengeId].accepted = true;\n    }\n\n    function updateChallengedTeam(\n        uint256 _challengeId,\n        address _newTeam2\n    ) public {\n        require(\n            msg.sender == matchChallenges[_challengeId].team1,\n            \"You're not the team1!\"\n        );\n        require(\n            matchChallenges[_challengeId].accepted != true,\n            \"Challenge has already been accepted!\"\n        );\n\n        matchChallenges[_challengeId].team2 = _newTeam2;\n    }\n\n    function deleteChallenge(uint256 _challengeId) public {\n        // Check\n        require(\n            matchChallenges[_challengeId].finished == false,\n            \"Challenge has already been finished!\"\n        );\n        require(\n            matchChallenges[_challengeId].started == false,\n            \"Challenge has already been started!\"\n        );\n        require(\n            msg.sender == matchChallenges[_challengeId].team1 ||\n                msg.sender == matchChallenges[_challengeId].team2,\n            \"You're not any of the teams!\"\n        );\n\n        // Effect\n        matchChallenges[_challengeId].finished = true;\n        // Interact\n        (bool success, ) = payable(matchChallenges[_challengeId].team1).call{\n            value: matchChallenges[_challengeId].amount\n        }(\"\");\n        if (matchChallenges[_challengeId].accepted == true) {\n            (bool success2, ) = payable(matchChallenges[_challengeId].team2)\n                .call{value: matchChallenges[_challengeId].amount}(\"\");\n        }\n    }\n\n    function startChallenge(uint256 _challengeId) public {\n        // Check\n        require(\n            matchChallenges[_challengeId].accepted == true,\n            \"Team2 hasn't accepted the challenge!\"\n        );\n        require(\n            matchChallenges[_challengeId].locationProvider == msg.sender,\n            \"You're not the location provider!\"\n        );\n        require(\n            matchChallenges[_challengeId].team2 != address(0),\n            \"Lacking a team or match canceled\"\n        );\n\n        // Effect\n        matchChallenges[_challengeId].started = true;\n    }\n\n    function completeChallenge(\n        uint256 _challengeId,\n        uint8 _team1Result,\n        uint8 _team2Result\n    ) public {\n        // Check\n        require(\n            matchChallenges[_challengeId].started == true,\n            \"Challenge hasn't started!\"\n        );\n        require(\n            matchChallenges[_challengeId].finished == false,\n            \"Challenge already completed\"\n        );\n        require(\n            matchChallenges[_challengeId].team2 != address(0),\n            \"There must be a team2!\"\n        );\n        require(\n            msg.sender == matchChallenges[_challengeId].locationProvider,\n            \"You must be the location provider to say who won\"\n        );\n        // Effect\n        matchChallenges[_challengeId].finished = true;\n        emit ChallengeResult(_challengeId, _team1Result, _team2Result);\n        // Interact\n        if (_team1Result > _team2Result) {\n            (bool success, ) = payable(matchChallenges[_challengeId].team1)\n                .call{value: matchChallenges[_challengeId].amount * 2}(\"\");\n        }\n        if (_team1Result < _team2Result) {\n            (bool success, ) = payable(matchChallenges[_challengeId].team2)\n                .call{value: matchChallenges[_challengeId].amount * 2}(\"\");\n        }\n        if (_team1Result == _team2Result) {\n            (bool success, ) = payable(matchChallenges[_challengeId].team1)\n                .call{value: matchChallenges[_challengeId].amount}(\"\");\n            (bool success2, ) = payable(matchChallenges[_challengeId].team2)\n                .call{value: matchChallenges[_challengeId].amount}(\"\");\n        }\n    }\n\n    function viewMatchChallenge(\n        uint256 _id\n    ) public view returns (address[3] memory) {\n        address team1 = matchChallenges[_id].team1;\n        address team2 = matchChallenges[_id].team2;\n        address locationProvider = matchChallenges[_id].locationProvider;\n        address[3] memory answer = [team1, team2, locationProvider];\n        return answer;\n    }\n\n    function isMatchAccepted(uint256 _id) public view returns (bool) {\n        return matchChallenges[_id].accepted;\n    }\n\n    function isMatchStarted(uint256 _id) public view returns (bool) {\n        return matchChallenges[_id].started;\n    }\n\n    function isMatchFinished(uint256 _id) public view returns (bool) {\n        return matchChallenges[_id].finished;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}